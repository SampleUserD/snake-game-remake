<html>
	<head>
		<title>Snake game</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}
		</style>
	</head>
	<body>
		<canvas id="canvas"></canvas>
		<script src="libs/errors/interface-implementation-error.js"></script>
		<script src="libs/errors/assertion-error.js"></script>
		<script src="libs/assert/assert.js"></script>
		<script>

			class RenderableObject 
			{
				Render(context)
				{
					throw new InterfaceImplementationError('RenderableObject', this.constructor.name, 'Render(context: CanvasRenderingContext2D)');
				}
			}

			class InteractableObject extends RenderableObject
			{
				constructor()
				{
					super();
				}
		
				OnInteract(Sender)
				{
					throw new InterfaceImplementationError('InteractableObject', this.constructor.name, 'OnInteract()');
				}
				Interact()
				{
					throw new InterfaceImplementationError('InteractableObject', this.constructor.name, 'Interact()');
				}
				Work()
				{
					throw new InterfaceImplementationError('InteractableObject', this.constructor.name, 'Work()');
				}
			}

			class MovableObject extends InteractableObject
			{
				constructor()
				{
					super();
				}

				OnMove()
				{
					throw new InterfaceImplementationError('InteractableObject', this.constructor.name, 'OnMove()');
				}
				Move(vector)
				{
					throw new InterfaceImplementationError('MovableObject', this.constructor.name, 'Move(vector)');
				}
			}

			class Player extends MovableObject
			{
				constructor()
				{
					super();
				}
			}

			class Controller extends RenderableObject 
			{
				constructor()
				{
					super();
				}

				Control(player)
				{
					throw new InterfaceImplementationError('Controller', this.constructor.name, 'Control(player: Player)');
				}
			}

			class SolidBlock extends InteractableObject {
				constructor(coordinates, size = 1) {
					super();

					this.coordinates = coordinates;
					this.size = size;
				}

				setCoordinates(coordinates) {
					this.coordinates = coordinates;
				}

				draw(context, configs, screen = []) {
					context.fillRect(this.coordinates[0], this.coordinates[1], this.size, this.size);
				}
				
				act(player, context, configs, screen = [], scene, index, direction)  {
					const head = player.blocks[0];

					if (head.x >= this.coordinates[0] && head.y >= this.coordinates[1] && head.x <= this.size + this.coordinates[0] && head.y <= this.size + this.coordinates[1]) {
						if (player.immortal) {
							return undefined;
						}
						
						// костыль, заменить на event'ы player'а
						if (player.health % (player.health/player.blocks.length) == 0 && Math.floor(player.health / (player.health/player.blocks.length)) >= 1) {
							player.health -= 1;			

							if (player.blocks.length > 2) {
								player.blocks.splice(player.blocks.length - 2, 1);
							}
						}

						if (Math.random() >= 1 - 0.02) {
							return undefined;
						}

						if (Math.random() >= 1 - 0.25) {
							player.health -= this.size;
						}

						if (player.blocks.length - 3 < 0) {
							player.health -= this.size;
						} else {
							if (Math.random() >= 1 - 0.05) {
								player.health -= 2*(this.size - (player.blocks.length - 3));
							}
						}
						
						if (this.size - (player.blocks.length - 3) >= 1) {
							player.health -= this.size - (player.blocks.length - 3);
						} else {
							player.health -= 1;
						}
					}
				}
			}

			class LightBlock {
				constructor(coordinates, size = 1) {
					this.coordinates = coordinates;
					this.size = size;

					// this.bullets = [[null, null]];
				}

				setCoordinates(coordinates) {
					this.coordinates = coordinates;
				}

				draw(context, configs, screen = []) {
					context.fillStyle = 'rgba(0, 0, 0, 0.75)';
					context.fillRect(this.coordinates[0], this.coordinates[1], this.size, this.size);
				}

				
				act(player, context, configs, screen = [], scene, index)  {
					const head = player.blocks[0];

					if (head.x + player.size >= this.coordinates[0] && head.y + player.size >= this.coordinates[1] && head.x <= this.size + this.coordinates[0] && head.y <= this.size + this.coordinates[1]) {
						scene.blocks[index] = null;
					}
				}
			}


			class Boss_TrapBomb {
				constructor(coordinates, size = 1) {
					this.coordinates = coordinates;
					this.size = size;

					this.summoned = false;
				}

				setCoordinates(coordinates) {
					this.coordinates = coordinates;
				}

				draw(context, configs, screen = []) {
					context.fillStyle = 'rgba(0, 0, 0, 0.75)';
					context.fillRect(this.coordinates[0], this.coordinates[1], this.size, this.size);

					context.fillStyle = 'rgba(255, 0, 0, 0.75)';
					context.strokeStyle = 'rgba(255, 0, 0, 0.75)';

					context.strokeRect(this.coordinates[0], this.coordinates[1], this.size, this.size);

					context.fillRect(this.coordinates[0] + configs.size, this.coordinates[1] - configs.size, this.size, this.size);
					context.fillRect(this.coordinates[0] + configs.size, this.coordinates[1], this.size, this.size);
					context.fillRect(this.coordinates[0] + configs.size, this.coordinates[1] + configs.size, this.size, this.size);

					context.fillRect(this.coordinates[0], this.coordinates[1] + configs.size, this.size, this.size);
					context.fillRect(this.coordinates[0] + configs.size, this.coordinates[1] + configs.size, this.size, this.size);
					context.fillRect(this.coordinates[0] - configs.size, this.coordinates[1] + configs.size, this.size, this.size);
				}

				
				act(player, context, configs, screen = [], scene, index)  {
					const head = player.blocks[0];

					if (!(player.blocks.length >= 6)) {
						return undefined;
					}

					if (!this.summoned && head.x + player.size >= this.coordinates[0] && head.y + player.size >= this.coordinates[1] && head.x <= this.size + this.coordinates[0] && head.y <= this.size + this.coordinates[1]) {
						player.health -= player.health/4 + this.size;
						let startTime = Date.now();

						scene.blocks[index].drawable = false;
						const currentBlock = scene.blocks[index];

						const maximalCount = (screen.width - screen.width%configs.size)/configs.size;

						scene.blocks.splice(index -1, 0, { position:  [this.coordinates[0]/configs.size + Math.round(maximalCount/4), this.coordinates[1]/configs.size + Math.round(maximalCount/4)], block: new Apple([], configs.size) });

						const createInvicibleSnipers = ((counter) => {
							if (counter > maximalCount) {
								return undefined;
							}

							const block = Object.assign({}, currentBlock);
							
							let invicibleSniper = new Sniper([], configs.size/2);
							// invicibleSniper.act(player, context, configs, screen);

							block.block = invicibleSniper;
							block.position = [counter, counter];

							scene.blocks.splice(index + counter, 0, block);

							if (counter < maximalCount) {
								createInvicibleSnipers(counter + 1);
							}
						});

						setTimeout(() => {
							for (let index = 0; index < 3; index++) {
								createInvicibleSnipers(0);
							}
						}, 500);

						this.summoned = true;
						configs.background = 'rgba(100, 225, 0, 0.5)';
					}
				}
			}


			class Apple {
				constructor(coordinates, size = 1) {
					this.block = new Block(coordinates || [], size);
					this.originCoordinates = [];
				}

				setCoordinates(coordinates) {
					if (this.originCoordinates.every(coordinate => coordinate === undefined)) {
						this.block.setCoordinates(coordinates);
						this.originCoordinates = [coordinates[0], coordinates[1]];
					}

					if (coordinates.every((coordinate, index) => coordinate !== this.originCoordinates[index])) {
						this.block.setCoordinates(coordinates);
					}
				}

				draw(context, configs, screen = []) {
					context.fillStyle = 'green';
					this.block.draw(context, configs, screen);
				}

				
				act(player, context, configs, screen = [], scene, index)  {
					const head = player.blocks[0];

					if (head.x + player.size >= this.block.coordinates[0] && head.y + player.size >= this.block.coordinates[1] && head.x <= this.block.size + this.block.coordinates[0] && head.y <= this.block.size + this.block.coordinates[1]) {
						const generateRandomPosition = () => {
							let appleX = Math.random()*screen.width;
							let appleY = Math.random()*screen.height;

							appleX = (screen.width%configs.size)/2 + appleX - appleX%configs.size;
							appleY = (screen.height%configs.size)/2 + appleY - appleY%configs.size;

							if (appleX >= screen.width - (screen.width%configs.size)/2 || appleY >= screen.height - (screen.width%configs.size)/2 || appleX <= (screen.width%configs.size)/2 || appleY <= (screen.width%configs.size)/2) {
								return generateRandomPosition();
							}
							
							if (!scene.blocks.find(block => block !== null && block.position[0] == (appleX - appleX%configs.size)/configs.size && block.position[1] == (appleY - appleY%configs.size)/configs.size)) {
								this.setCoordinates([ appleX, appleY ]);
							} else {
								return generateRandomPosition();
							}

							player.score += 1;

							if (player.health <= 500 - player.size) {
								player.health += player.size;
							}
						};

						player.blocks.push({ x: player.blocks[0].x, y: player.blocks[1].y });
						generateRandomPosition();
					}
				}
			}


			class Sniper {
				constructor(coordinates, velocity = 1) {
					this.coordinates = coordinates;
					this.velocity = velocity;

					this.bullet = new Block([]);
					this.playerDirection = [null, null];

					this.previousBulletStates = [[0, 0]];

					// this.bullets = [[null, null]];
				}

				setCoordinates(coordinates) {
					this.coordinates = coordinates;
				}

				draw(context, configs, screen = []) {
					context.fillStyle = 'black';
					context.fillRect(this.coordinates[0], this.coordinates[1], configs.size, configs.size);
					context.fillRect(this.coordinates[0] + configs.size, this.coordinates[1], configs.size/4, configs.size);
					context.fillRect(this.coordinates[0] - configs.size/4, this.coordinates[1], configs.size/4, configs.size);
					context.fillRect(this.coordinates[0], this.coordinates[1] + configs.size, configs.size, configs.size/4);
					context.fillRect(this.coordinates[0], this.coordinates[1] - configs.size/4, configs.size, configs.size/4);
				}

				act(player, context, configs, screen = [])  {
					if(this.playerDirection.every(direction => direction == null)) {
						this.playerDirection[0] = player.blocks[0].x;
						this.playerDirection[1] = player.blocks[1].y;
					}

					if (this.bullet.coordinates.every(coordinate => coordinate === 0)) {
						this.bullet.setCoordinates(this.coordinates);
						this.bullet.size = (configs.size);
					}

					// this.bullet.size += 1;

					this.previousBulletStates[0] = Object.assign([], this.bullet.coordinates);

					const hypot = Math.sqrt((this.playerDirection[0] - this.coordinates[0])**2 + (this.playerDirection[1] - this.coordinates[1])**2);

					this.bullet.coordinates[0] += this.velocity*((this.playerDirection[0] - this.coordinates[0])/hypot);
					this.bullet.coordinates[1] += this.velocity*((this.playerDirection[1] - this.coordinates[1])/hypot);
					// this.bulletDirection[1] += 0.1;
					
					// console.log(this.bulletDirection)

					if (this.bullet.coordinates[0] <= 0 || this.bullet.coordinates[0] >= screen.width) {
						this.bullet.coordinates[0] = 0;
						this.playerDirection[0] =  null;

						// this.bullet.size = configs.size;
					}

					if (this.bullet.coordinates[1] <= 0 ||this.bullet.coordinates[1] >= screen.height) {
						this.bullet.coordinates[1] = 0;
						this.playerDirection[1] = null;

						// this.bullet.size = configs.size;
					}

					if (this.previousBulletStates[0].some((coordinate, index) => coordinate === this.bullet.coordinates[index])) {
						this.bullet.setCoordinates([ this.coordinates[0], this.coordinates[1] ]);
						this.playerDirection[0] =  null;
						this.playerDirection[1] =  null;
					}

					context.fillStyle = 'black';
					this.bullet.act(player, context, configs, screen);
					this.bullet.draw(context, configs, screen);
				}
			}

			class MagicTower {
				constructor(coordinates, velocity = 1) {
					this.coordinates = coordinates;
					this.velocity = velocity;

					this.bullet = new Block([]);
					this.playerDirection = [null, null];

					this.previousBulletStates = [[0, 0]];

					// this.bullets = [[null, null]];
				}

				setCoordinates(coordinates) {
					this.coordinates = coordinates;
				}

				draw(context, configs, screen = []) {
					context.fillStyle = 'rgba(255, 0, 0, 0.85)';
					context.fillRect(this.coordinates[0], this.coordinates[1], configs.size, configs.size);
					context.fillRect(this.coordinates[0] + configs.size, this.coordinates[1], configs.size/4, configs.size);
					context.fillRect(this.coordinates[0] - configs.size/4, this.coordinates[1], configs.size/4, configs.size);
					context.fillRect(this.coordinates[0], this.coordinates[1] + configs.size, configs.size, configs.size/4);
					context.fillRect(this.coordinates[0], this.coordinates[1] - configs.size/4, configs.size, configs.size/4);
				}

				act(player, context, configs, screen = [])  {
					if(this.playerDirection.every(direction => direction == null)) {
						this.playerDirection[0] = player.blocks[0].x;
						this.playerDirection[1] = player.blocks[1].y;
					}

					if (this.bullet.coordinates.every(coordinate => coordinate === 0)) {
						this.bullet.setCoordinates(this.coordinates);
						this.bullet.size = configs.size;
					}

					// this.bullet.size += 1;

					this.previousBulletStates[0] = Object.assign([], this.bullet.coordinates);

					const hypot = Math.sqrt((this.playerDirection[0] - this.coordinates[0])**2 + (this.playerDirection[1] - this.coordinates[1])**2);

					this.bullet.coordinates[0] += this.velocity*((this.playerDirection[0] - this.coordinates[0])/hypot);
					this.bullet.coordinates[1] += this.velocity*((this.playerDirection[1] - this.coordinates[1])/hypot);
					
					this.bullet.size += (configs.size - configs.size%10)/10;
					
					// console.log(this.bulletDirection)

					if (this.bullet.coordinates[0] <= 0 || this.bullet.coordinates[0] >= screen.width) {
						this.bullet.coordinates[0] = 0;
						this.playerDirection[0] =  null;

						// this.bullet.size = configs.size;
					}

					if (this.bullet.coordinates[1] <= 0 ||this.bullet.coordinates[1] >= screen.height) {
						this.bullet.coordinates[1] = 0;
						this.playerDirection[1] = null;

						this.bullet.size = configs.size;
					}

					if (this.previousBulletStates[0].some((coordinate, index) => coordinate === this.bullet.coordinates[index])) {
						this.bullet.setCoordinates([ this.coordinates[0], this.coordinates[1] ]);
						this.playerDirection[0] =  null;
						this.playerDirection[1] =  null;

						this.bullet.size = configs.size;
					}

					context.fillStyle = 'black';
					this.bullet.act(player, context, configs, screen);
					this.bullet.draw(context, configs, screen);
				}
			}
			
			window.onload = function() {
				const canvas = document.querySelector("#canvas");
				const context = canvas.getContext("2d");
				
				canvas.width = innerHeight;
				canvas.height = innerHeight;

				canvas.style.marginLeft = Math.abs(innerHeight*0.5 - canvas.width);
				
				let direction = [1, 0];

				const pages = [0, 0];
				
				window.onkeydown = function(event) {
					let code = event.code.toLowerCase();
					
					if (code == 'keya' && direction[0] != 1) {
						direction[0] = -1;
						direction[1] = 0;
					}
					
					if (code == 'keyd' && direction[0] != -1) {
						direction[0] = 1;
						direction[1] = 0;
					}
					
					if (code == 'keyw' && direction[1] != 1) {
						direction[1] = -1;
						direction[0] = 0;
					}
					
					if (code == 'keys' && direction[1] != -1) {
						direction[1] = 1;
						direction[0] = 0;
					}

					if (code == 'space') {
						direction[0] = 0;
						direction[1] = 0;
					}
				};
				

				const blockConfigs = { size: 10, background: 'transparent' }; // 15

				const lengthX = (canvas.width - canvas.width%blockConfigs.size)/blockConfigs.size;
				const lengthY = (canvas.height - canvas.height%blockConfigs.size)/blockConfigs.size;

				const borderOffsetX = (canvas.width - lengthX * blockConfigs.size)/2;
				const borderOffsetY = (canvas.height - lengthY * blockConfigs.size)/2;

				let won = false;

				let player = { blocks: [{ x: borderOffsetX, y: borderOffsetY }, { x: borderOffsetX+blockConfigs.size, y: borderOffsetY }], health: 500, size: blockConfigs.size, score: 0, immortal: false };
				let levelsCompleted = 0;

				const scenes = [];
				const gameConfiguration = { drawAxes: false };


				function __init()
				{
					for (let blockPosition = 0; blockPosition < lengthX; blockPosition++)
					{
						const scene = scenes.find(scene => scene.scene[0] == 0 && scene.scene[1] == 0) || { blocks: [], completed: true };

						scene.blocks.push({ position: [blockPosition, Math.round(lengthY / 4)], block: new LightBlock([], blockConfigs.size) });
						scene.blocks.push({ position: [blockPosition, lengthY - Math.round(lengthY / 4) - 3], block: new LightBlock([], blockConfigs.size) });
					}

					context.clearRect(0, 0, canvas.width, canvas.height);
					context.font = '20px Helvetica';
					context.textBaseline = 'middle';
					context.textAlign = 'center';
				}
				function __playerMove(lastBlock)
				{
					lastBlock.x = player.blocks[0].x + direction[0] * player.size;
					lastBlock.y = player.blocks[0].y + direction[1] * player.size;

					player.blocks.unshift(lastBlock);

					startTime = Date.now();

					if (lastBlock.x > canvas.width - borderOffsetX)
					{
						lastBlock.x = 0 + borderOffsetX;
					} 
					else if (lastBlock.x < 0 + borderOffsetX)
					{
						lastBlock.x = canvas.width - borderOffsetX;
					} 
					else if (lastBlock.y > canvas.height - borderOffsetY)
					{
						lastBlock.y = 0 + borderOffsetY;
					} 
					else if (lastBlock.y < 0 + borderOffsetY)
					{
						lastBlock.y = canvas.height - borderOffsetY;
					}
				}
				function __onSceneCompleted()
				{
					if (won)
					{
						for (let index = 1; index < player.blocks.length; index++)
						{
							let block = player.blocks[index];

							player.blocks.splice(index, 1);

							block.x = lastBlock.x + direction[0] * player.size * (index);
							block.y = lastBlock.y + direction[1] * player.size * (index);

							player.blocks.unshift(block);
						}

						pages[Math.abs(direction[1])] += direction[Math.abs(direction[1])];
					}
				}
				function __onPlayerDeath()
				{
					if (player.health <= 0) 
					{
						alert(deathMessages[Math.floor(Math.random() * deathMessages.length)]);
						window.location.reload();

						return undefined;
					}
				}
				function __scoreWin()
				{
					won = (scenes.find(scene => scene.scene.every((page, index) => page == pages[index])) || { completed: false }).completed;

					if (!scenes.find(scene => scene.scene.every((page, index) => page == pages[index]))) {
						won = true;
					}
				}
				function __renderAxes()
				{
					if (gameConfiguration.drawAxes) 
					{
						context.beginPath();
						context.strokeStyle = 'black';

						for (let x = 0; x < 2*lengthX; x++) 
						{
							if (2*borderOffsetX + x * blockConfigs.size > canvas.width) {
								break;
							}

							context.moveTo(borderOffsetX + x * blockConfigs.size, borderOffsetY);
							context.lineTo(borderOffsetX + x * blockConfigs.size, canvas.height - borderOffsetY);
						}

						for (let y = 0; y < 2*lengthY; y++) 
						{
							if (2*borderOffsetY + y * blockConfigs.size > canvas.height) {
								break;
							}

							context.moveTo(borderOffsetX, borderOffsetY + y * blockConfigs.size);
							context.lineTo(canvas.width - borderOffsetX, borderOffsetY + y * blockConfigs.size);
						}

						context.stroke();
						context.beginPath();
					}					
				}
				function __killPlayer()
				{
					for (let index = 1; index < player.blocks.length; index++)
					{
						const block = player.blocks[index];

						if (direction[0] === 0 && direction[1] === 0 || player.immortal)
						{
							break;
						}

						if (player.blocks[0].x + player.size > block.x && player.blocks[0].y + player.size > block.y && player.blocks[0].x < block.x + blockConfigs.size && player.blocks[0].y < block.y + blockConfigs.size)
						{
							player.health = -1;
						}
					}
				}

				let startTime = Date.now();
				let timingBeforeEnterAnotherRoom = startTime;

				const deathMessages = [ `You're dead`, `Ambulance was calling you`, `You should be alive`, `Press OK!`, `Repeat it, press button`, `You're crawling like a boss`, `MMM, delicious snake on da ground!`, `There ain't valley of snake...`, `You should be at next door right now...` ];
				
				const startSpeedCoefficient = 30 + (player.blocks.length - 3)*2;
				let speedCoefficient = startSpeedCoefficient;

				__init();

				requestAnimationFrame(function loop() {
					context.clearRect(0, 0, canvas.width, canvas.height);
					
					if (Date.now() - startTime >= speedCoefficient) {
						const lastBlock = player.blocks.splice(player.blocks.length - 1, 1);
						
						if (
							lastBlock.x + player.size > canvas.width - borderOffsetX || 
							lastBlock.x + player.size < 0 + borderOffsetX || 
							lastBlock.y + player.size > canvas.height - borderOffsetY ||
							lastBlock.y + player.size < 0 + borderOffsetY
						) {
							__playerMove();
							__onSceneCompleted();
						}

						if (player.blocks.length > 2) {
							speedCoefficient = startSpeedCoefficient + (player.blocks.length - 3)*2;
						}

						__killPlayer();
					}

					context.fillStyle = `rgba(${ Math.abs(pages[0]*17)%255 },${  Math.abs(pages[1]*17)%255 },${  Math.abs(pages[0] + pages[1])*17%255 },0.85)`;
					context.fillRect(0, 0, canvas.width, canvas.height);

					__scoreWin();
					__onPlayerDeath();

					context.fillStyle = 'white';

					context.fillRect(borderOffsetX, borderOffsetY, canvas.width - borderOffsetX*2, canvas.height - borderOffsetY*2);

					context.fillStyle = `black`;
					context.fillText(`(${ pages[0] }:${ pages[1] })`, canvas.width/2, 10 + borderOffsetY);

					context.fillStyle = `red`;

					if (!player.immortal) {
						context.fillText(`Health remain: ${ player.health }`, canvas.width / 2, canvas.height / 2);
					} else {
						context.fillText(`You're immortal`, canvas.width / 2, canvas.height / 2);
					}

					context.fillStyle = `green`;
					context.fillText(`Speed: ${ (200 + blockConfigs.size - speedCoefficient)/blockConfigs.size } block/second`, canvas.width / 2, canvas.height / 2 + 50);

					context.fillText(`Absorbtion: ${ player.blocks.length - 3 } damage`, canvas.width / 2, canvas.height / 2 + 50*2);

					context.fillStyle = `black`;

					scenes.forEach(scene => {
						if (pages[0] === scene.scene[0] && pages[1] === scene.scene[1]) {
							if (!scene.completed) {
								scene.blocks.forEach((block, index) => {
									if (block === null) {
										return undefined;
									}

									block.block.setCoordinates([block.position[0]*blockConfigs.size + borderOffsetX, block.position[1]*blockConfigs.size + borderOffsetY]);

									if (!('drawable' in block) || block.drawable) {
										block.block.draw(context, blockConfigs, { width: canvas.width, height: canvas.height });
									}

									if (!('actable' in block) || block.actable) {
										block.block.act(player, context, blockConfigs, { width: canvas.width, height: canvas.height }, scene, index, direction);
									}
								});
							} else {
								scene.blocks.forEach((block, index) => {
									if (block === null || block.block instanceof Apple || !(block.drawable || !('drawable' in block))) {
										return undefined;
									}

									context.strokeStyle = 'red';
									context.strokeRect(block.position[0]*blockConfigs.size + borderOffsetX, block.position[1]*blockConfigs.size + borderOffsetY, blockConfigs.size, blockConfigs.size);
									
									context.fillStyle = 'rgba(0, 0, 0, 0.6)';
									context.fillRect(block.position[0]*blockConfigs.size + borderOffsetX, block.position[1]*blockConfigs.size + borderOffsetY, blockConfigs.size, blockConfigs.size);
								});
							}
						}
					});

					if ((scenes.find(scene => scene.blocks.some(block => block !== null && block.block instanceof Boss_TrapBomb)) || { completed: false }).completed == true) {
						player.immortal = true;
						blockConfigs.background = 'transparent';
					}

					if (player.score >= 5) {
						scenes.find(scene => scene.scene.every((page, index) => page === pages[index])).completed = true;
						
						won = true;
						levelsCompleted += 1;

						player.health = 500 + levelsCompleted*50;
						player.score = 0;
					}

					if (player.health <= 250) {
						blockConfigs.background = `rgba(255, 0, 0, ${ (1 - (player.health)/1000) >= 0.75 ? 0.75 : (1 - (player.health)/1000) })`;
					}

					context.fillStyle = blockConfigs.background;
					context.fillRect(borderOffsetX, borderOffsetY, canvas.width - borderOffsetX, canvas.height - borderOffsetY);

					__renderAxes();

					context.fillStyle = 'red';
					
					player.blocks.forEach(function(block) 
					{
						context.fillRect(block.x, block.y, player.size, player.size);
					});
					
					requestAnimationFrame(loop);
				});
			}
			
		</script>
	</body>
</html>